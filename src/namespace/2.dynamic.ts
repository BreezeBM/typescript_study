export {}
/* 
응용 프로그램이 커지면서 첫 렌더링 시간이 길어진다. 이 문제는 병목이 생기기 쉬운 프론트 엔드 응용프로그램에서 많이 발생한다. 
백엔드 프로그램에서도 최상위 수준에서 많은 코드를 임포트 하면 시작시 파일시스템으로 부터 코드를 로딩, 컴파일, 평가로 인해서 다른 코드 실행을 블록하여 문제가 발생할 수 있다.

필요할 때만 코드를 로딩하는 Lazy loading의 개념이 생겼고 이를 동적 임포트라는 개념으로 공식화 했다.
let locale = await from('locale')
 
import에는 문자열로 평가되는 표현식이라면 무엇이든 전달할 수 있지만, 대신 타입안정성을 잃게 된다. 동적 임포트를 하려면 다음 두 방법중 하나를 이용해야한다.
1. 문자열을 변수에 할당하지 않고 import에 문자열 리터럴로 직접 제공
2. import에 표현식을 전달하고 모듈의 시그니처를 명시 

CommonJS default export는 ES2015 default export와 궁합이 맞지 않다. default export가 필요하면 와일드 카드 임포트를 사용한다.
import * as fs from 'fs'

compilerOptions에서 "esModuleInterop": true로 설정하면 와일드 카드가 사라진다.

모듈몯 VS 스크립트 모드 
타입스트립트는 위의 두 모드중에 하나로 파싱을 한다. 파일에 import나 export가 있으면 모듈모드로 동작하게 된다. 
모듈 모드에서는 다른 파일의 코드를 가져올 때, import import()를 사용하고 다른 파일에 코드를 제공할 때 export를 사용한다.

서드파티 UMD모듈의 경우에는 이들을 먼저 import해야하고 그렇지 않으면 이들의 전역 export를 바로 사용할 수 없다. 

스크립트 모드에서는 최상위 수준으로 선언된 모든 변수는 명시적으로 import하지 않아도 같은 프로젝트의 다른 파일들에서 사용이 가능하다. 
*/



